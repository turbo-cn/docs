---
title: 配置选项 - turbo.json
description: 了解如何配置Turborepo通过 `turbo.json`.
---

import Callout from "../../../../components/Callout";
import OutputModeTable from "../../../../components/output-mode-table.mdx";

# 配置选项 (`turbo.json`)

您可以通过添加一个' turbo '来配置' turbo '的行为。 json '文件在你的monorepo的根目录中(也就是你为Yarn和npm用户指定的' workspace '键)。

## `globalDependencies`

`type: string[]`

用于隐式全局哈希依赖项的文件glob列表。 这些文件的内容将包含在全局哈希算法中，并影响所有任务的哈希。
这对于基于'销毁缓存非常有用。 env '文件(不在Git中)或任何影响工作空间任务的根级文件(但没有在传统的依赖关系图中表示(例如根' tsconfig. env ')。 Json '， ' jest.config.js '， ' .eslintrc '等))。
**Example**

```jsonc
{
  "$schema": "https://turborepo.org/schema.json",
  "pipeline": {
    // ... 为了简便起见,我们省略了
  },

  "globalDependencies": [
    ".env", // 内容将影响所有任务的散列
    "tsconfig.json" // 内容将影响所有任务的散列
  ]
}
```

## `globalEnv`

`type: string[]`

用于隐式全局哈希依赖项的环境变量列表。 这些环境变量的内容将包含在全局哈希算法中，并影响所有任务的哈希。
**Example**

```jsonc
{
  "$schema": "https://turborepo.org/schema.json",
  "pipeline": {
    // ... omitted for brevity
  },

  "globalEnv": ["GITHUB_TOKEN"] // value will impact the hashes of all tasks
}
```

## `pipeline`
表示项目的任务依赖关系图的对象。 ' turbo '解释这些约定，以正确地调度、执行和缓存项目中任务的输出。

“pipeline”对象中的每个键都是可以通过“turbo run”执行的任务的名称。 如果' turbo '找到一个带有' package. net '的工作区。 Json ' ' scripts '对象具有匹配的键，它将在执行过程中将管道任务配置应用到该NPM脚本。 这允许你使用“管道”在整个Turborepo中设置约定。

```jsonc
{
  "$schema": "https://turborepo.org/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"]
    },
    "test": {
      "outputs": ["coverage/**"],
      "dependsOn": ["build"],
      "inputs": ["src/**/*.tsx", "src/**/*.ts", "test/**/*.ts"],
      "outputMode": "full"
    },
    "dev": {
      "cache": false
    }
  }
}
```

### `dependsOn`

`type: string[]`

此任务所依赖的任务列表。

在' dependsOn '中给一个项目加上' ^ '前缀，告诉' turbo '这个管道任务依赖于工作区的拓扑依赖关系，首先用' ^ '前缀完成任务(例如。 “一个工作区的‘构建’任务应该只在它的所有‘依赖’和‘devDependencies’完成它们自己的‘构建’命令后才运行”)。

在' dependsOn '中没有' ^ '前缀的项目，表示工作空间级别的任务之间的关系(例如: “一个工作区的‘test’和‘lint’命令依赖于‘build’首先完成”)。

在' dependsOn '中的项目前面加上' $ '，告诉' turbo '该管道任务依赖于该环境变量的值。
<Callout type="info">
 使用' $ '在' dependsOn '配置中声明环境变量是
 弃用。 使用' env '键代替。
</Callout>

**Example**

```jsonc
{
  "$schema": "https://turborepo.org/schema.json",
  "pipeline": {
    "build": {
      // "一个工作区的“构建”命令取决于它的依赖关系 '
      // 或者先完成devDependencies的' build '命令"
      "dependsOn": ["^build"]
    },
    "test": {
      // “一个工作区的‘test’命令依赖于它自己的‘lint’和
      // `build` 命令首先被完成”
      "dependsOn": ["lint", "build"]
    },
    "deploy": {
      //  一个工作区的“部署”deploy，取决于它自己的“build”
      // ' test '命令首先被完成"

      "dependsOn": ["build", "test"]
    },
    // 工作区的' lint '命令没有依赖性
    "lint": {}
  }
}
```

### `env`

`type: string[]`

任务所依赖的环境变量列表。

**Example**

```jsonc
{
  "$schema": "https://turborepo.org/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "env": ["SOMETHING_ELSE"], // 值将影响所有构建任务的散列
      "outputs": ["dist/**", ".next/**"]
    },
    "web#build": {
      "dependsOn": ["^build"],
      "env": ["STRIPE_SECRET_KEY"], // 值只会影响web的构建任务的散列
      "outputs": [".next/**"]
    }
  },
  "globalEnv": [
    "GITHUB_TOKEN" // 值将影响所有任务的散列
  ]
}
```

<Callout type="info">
  当Turborepo在工作空间中检测到公共前端框架时，它就会这样做
  自动依赖于将内联的环境变量
  您的构建。 例如，如果“web”工作区包含Next.js项目，
  您不需要指定任何环境变量[以
  ' NEXT_PUBLIC_ '] (https://nextjs.org/docs/basic-features/environment-variables # exposing-environment-variables-to-the-browser)
  在' dependsOn '配置中。 Turborepo已经知道构建输出将会
  当这些环境变量的值发生变化时，也会发生变化，因此它将取决于
  自动。 更多信息请参见[文档上
  缓存](/ docs /核心概念/缓存# automatic-environment-variable-inclusion)。
</Callout>

### `outputs`

`type: string[]`

默认为' ["dist/**"， "build/**"] '。 任务的可缓存文件系统输出的glob模式集。

注意:`turbo` 自动记录`stderr`/`stdout` to`.turbo/run-<task>.log`. 这个文件总是被视为可缓存的工件，从来不需要指定。

传递一个空数组可以用来告诉' turbo '一个任务是一个副作用，因此不会产生任何文件系统工件(例如，linter)，但您仍然希望缓存它的日志(并将它们视为工件)。
**Example**

```jsonc
{
  "$schema": "https://turborepo.org/schema.json",
  "pipeline": {
    "build": {
      // "缓存发送到工作区的dist/**或。next的所有文件
      // 目录由'build'任务"
      "outputs": ["dist/**", ".next/**"],
      "dependsOn": ["^build"]
    },
    "test": {
      // "不缓存'test'任务的任何工件(除了
      / /日志)”
      "outputs": [],
      "dependsOn": ["build"]
    },
    "test:ci": {
      // "缓存' test:ci '命令的覆盖率报告"
      "outputs": ["coverage/**"],
      "dependsOn": ["build"]
    },
    "dev": {
      // 从不缓存对象发出的任何内容(包括日志)
       // dev的任务
      "cache": false
    }
  }
}
```

### `cache`

`type: boolean`

默认为“真正的”。 是否缓存任务[' outputs '](#outputs)。 将' cache '设置为false对于您不想缓存的守护进程或长时间运行的“监视”或开发模式任务非常有用。
**Example**

```jsonc
{
  "$schema": "https://turborepo.org/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"]
    },
    "test": {
      "outputs": [],
      "dependsOn": ["build"]
    },
    "dev": {
      "cache": false
    }
  }
}
```

### `inputs`

`type: string[]`

默认为“[]”。 告诉' turbo '在确定工作空间是否为特定任务更改时要考虑的文件集。
将此设置为一个glob列表将导致只有当匹配这些glob的文件存在时才重新运行任务
改变了。 例如，如果您想要跳过运行测试，除非源文件更改，那么这将很有帮助。

指定'[]'将导致当工作区中的任何文件更改时重新运行任务。
**Example**

```jsonc
{
  "$schema": "https://turborepo.org/schema.json",
  "pipeline": {
    // ... omitted for brevity

    "test": {
      //工作空间的“测试”任务依赖于该工作空间的
      //自己的' build '任务首先完成。
      "dependsOn": ["build"],
      "outputs": [""],
      // 工作区的“test”任务应该只在以下情况下重新运行
         // either a '。 tsx’或‘。 Ts的文件已更改。
      "inputs": ["src/**/*.tsx", "src/**/*.ts", "test/**/*.ts"]
    }
  }
}
```

<Callout type="info">

  注意:`turbo.json`总是被认为是输入。 如果你修改
  `turbo.json`，所有缓存都无效。
</Callout>

### `outputMode`

`type: "full" | "hash-only" | "new-only" | "none"`

Set type of output logging.

<OutputModeTable />

**Example**

```jsonc
{
  "$schema": "https://turborepo.org/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputMode": "new-only"
    },
    "test": {
      "outputs": [],
      "dependsOn": ["build"]
    }
  }
}
```
